// See the LICENSE file for license details.

package main

import (
	"archive/zip"
	"bytes"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

const (
	mimallocVersion = "v2.1.7"
)

var (
	errFileNotFound = errors.New("file not found")

	regexFindPragmaOnce = regexp.MustCompile("^\\s*#\\s*pragma\\s+once\\s*$")
	regexFindInclude    = regexp.MustCompile("^\\s*#\\s*include\\s+\"(.*)\"\\s*$")
)

// -----------------------------------------------------------------------------

func main() {
	var contents []byte

	g, err := newGenerator()
	if err != nil {
		panic(err.Error())
	}

	// Download source code
	fmt.Printf("Downloading MiMalloc from GitHub... ")
	err = g.downloadFile("https://github.com/microsoft/mimalloc/archive/refs/tags/" + mimallocVersion + ".zip")
	if err != nil {
		fmt.Printf("\n")
		panic(err.Error())
	}
	fmt.Printf("OK\n")

	// Read license file
	fmt.Printf("Extracting license file... ")
	contents, err = g.readZipFile("LICENSE")
	if err != nil {
		fmt.Printf("\n")
		panic(err.Error())
	}
	fmt.Printf("OK\n")

	// Append custom text
	contents = append(contents, []byte(`
--------------------------------------------------------------------------------

Golang wrapper created by Mauro H. Leggieri.
The original license is preserved.
`)...)
	contents = fixNewLines(contents)

	// Write license file
	fmt.Printf("Writing license file... ")
	err = g.writeFile("LICENSE", contents)
	if err != nil {
		fmt.Printf("\n")
		panic(err.Error())
	}
	fmt.Printf("OK\n")

	// -------------------------------------------------------------------------

	fmt.Printf("Extracting readme file... ")
	contents, err = g.readZipFile("readme.md")
	if err != nil {
		fmt.Printf("\n")
		panic(err.Error())
	}
	fmt.Printf("OK\n")

	contents = fixNewLines(contents)

	// Write readme file
	fmt.Printf("Writing readme file... ")
	err = g.writeFile("MIMALLOC_README.md", contents)
	if err != nil {
		fmt.Printf("\n")
		panic(err.Error())
	}
	fmt.Printf("OK\n")

	// -------------------------------------------------------------------------

	fmt.Printf("Building amalgamation... ")
	err = g.process("src/static.c")
	if err != nil {
		fmt.Printf("\n")
		panic(err.Error())
	}
	fmt.Printf("OK\n")

	// Prepend custom text
	contents = append([]byte(`// Code generated by go-mimalloc/internal/gen - DO NOT EDIT.")

`), strings.Join(g.amalgamationLines, "\n")...)
	contents = fixNewLines(contents)

	// Write readme file
	fmt.Printf("Writing amalgamation file... ")
	err = g.writeFile("mimalloc_amalgamation.h", contents)
	if err != nil {
		fmt.Printf("\n")
		panic(err.Error())
	}
	fmt.Printf("OK\n")
}

// -----------------------------------------------------------------------------

type generator struct {
	currDir string

	zipFileContents bytes.Buffer
	zipReader       *zip.Reader

	amalgamationLines []string
	processedFiles    map[string]struct{}
}

// -----------------------------------------------------------------------------

func newGenerator() (*generator, error) {
	var err error

	g := generator{
		amalgamationLines: make([]string, 0),
		processedFiles:    make(map[string]struct{}),
	}
	g.currDir, err = os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("unable to get current directory [err=%v]", err)
	}
	if !strings.HasSuffix(g.currDir, string(os.PathSeparator)) {
		g.currDir += string(os.PathSeparator)
	}
	return &g, nil
}

func (g *generator) downloadFile(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("unable to download source code [err=%v]", err)
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	_, err = io.Copy(&g.zipFileContents, resp.Body)
	if err != nil {
		return fmt.Errorf("unable to download source code [err=%v]", err)
	}

	g.zipReader, err = zip.NewReader(bytes.NewReader(g.zipFileContents.Bytes()), int64(g.zipFileContents.Len()))
	if err != nil {
		return fmt.Errorf("unable to decompress source code [err=%v]", err)
	}

	return nil
}

func (g *generator) doesZipFileExist(fileName string) bool {
	for _, file := range g.zipReader.File {
		if !file.FileInfo().IsDir() {
			// Strip root path
			name := file.Name
			idx := strings.Index(name, "/")
			if idx >= 0 {
				name = name[idx+1:]
			}

			if fileName == name {
				return true
			}
		}
	}
	return false
}

func (g *generator) readZipFile(fileName string) ([]byte, error) {
	for _, file := range g.zipReader.File {
		if !file.FileInfo().IsDir() {
			// Strip root path
			name := file.Name
			idx := strings.Index(name, "/")
			if idx >= 0 {
				name = name[idx+1:]
			}

			if fileName == name {
				fileReader, err := file.Open()
				if err != nil {
					return nil, err
				}
				buf := new(bytes.Buffer)
				_, err = io.Copy(buf, fileReader)
				_ = fileReader.Close()
				if err != nil {
					return nil, err
				}
				return buf.Bytes(), nil
			}
		}
	}
	return nil, errFileNotFound
}

func (g *generator) writeFile(fileName string, contents []byte) error {
	f, err := os.Create(filepath.Join(g.currDir, fileName))
	if err == nil {
		_, err = f.Write(contents)
		_ = f.Close()
	}
	return err
}

func (g *generator) process(fileName string) error {
	contents, err := g.readZipFile(fileName)
	if err != nil {
		if errors.Is(err, errFileNotFound) {
			return fmt.Errorf("'%v' %v", fileName, errFileNotFound.Error())
		}
		return err
	}

	// Process only if not processed before
	if _, ok := g.processedFiles[fileName]; ok {
		return nil
	}
	g.processedFiles[fileName] = struct{}{}

	g.amalgamationLines = append(g.amalgamationLines, fmt.Sprintf("// START OF %v", fileName))

	// NOTE: We are assuming there is no include statement inside a multiline comment
	for len(contents) > 0 {
		idx := bytes.IndexByte(contents, '\r')
		if idx < 0 {
			idx = len(contents)
		}
		idx2 := bytes.IndexByte(contents, '\n')
		if idx2 < 0 {
			idx2 = len(contents)
		}
		if idx2 < idx {
			idx = idx2
		}

		// Get line
		line := contents[:idx]
		for idx < len(contents) {
			if contents[idx] != '\r' && contents[idx] != '\n' {
				break
			}
			idx += 1
		}
		contents = contents[idx:]

		// Locate start of single-line comment, if any
		commentIdx := bytes.Index(line, []byte{'/', '/'})
		if commentIdx < 0 {
			commentIdx = len(line)
		}

		// Remove all pragma once
		m := regexFindPragmaOnce.FindStringSubmatch(string(line[:commentIdx]))
		if m != nil {
			continue
		}

		// Check if we are on a #include sentence
		m = regexFindInclude.FindStringSubmatch(string(line[:commentIdx]))
		if m == nil {
			g.amalgamationLines = append(g.amalgamationLines, string(line))
		} else {
			baseDir, _ := splitDirFileName(fileName)
			includeDir, includeFileName := splitDirFileName(m[1])

			finalDir, ok := mergeDirs(baseDir, includeDir)
			if !ok {
				return fmt.Errorf("inclusion of '%v' leads to wrong path", m[1])
			}
			// fmt.Println(baseDir, "-", includeDir, "-", finalDir, "-", includeFileName)
			if g.doesZipFileExist(finalDir + "/" + includeFileName) {
				err = g.process(finalDir + "/" + includeFileName)
			} else if g.doesZipFileExist("include/" + m[1]) {
				err = g.process("include/" + m[1])
			} else {
				finalDir, ok = mergeDirs("include", includeDir)
				if ok && g.doesZipFileExist(finalDir+"/"+includeFileName) {
					err = g.process(finalDir + "/" + includeFileName)
				} else {
					err = fmt.Errorf("inclusion of '%v' from '%v' leads to missing file", m[1], fileName)
				}
			}
			if err != nil {
				return err
			}
		}
	}

	g.amalgamationLines = append(g.amalgamationLines, fmt.Sprintf("// END OF %v", fileName))
	return nil
}

func splitDirFileName(name string) (string, string) {
	idx := strings.LastIndex(name, "/")
	if idx < 0 {
		return "", name
	}
	return name[:idx], name[idx+1:]
}

func mergeDirs(base string, toAdd string) (string, bool) {
	toAddParts := strings.Split(toAdd, "/")
	baseParts := strings.Split(base, "/")
	for _, toAddPart := range toAddParts {
		if len(toAddPart) > 0 && toAddPart != "." {
			if toAddPart == ".." {
				if len(baseParts) == 0 {
					return "", false
				}
				baseParts = baseParts[0 : len(baseParts)-1]
			} else {
				baseParts = append(baseParts, toAddPart)
			}
		}
	}
	return strings.Join(baseParts, "/"), true
}

func fixNewLines(contents []byte) []byte {
	contents = bytes.ReplaceAll(contents, []byte("\r\n"), []byte("\n"))
	contents = bytes.ReplaceAll(contents, []byte("\r"), []byte("\n"))
	return contents
}
